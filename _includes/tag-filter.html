{%- comment -%} Collect all tags from posts {%- endcomment -%}
{%- assign all_tags_raw = "" | split: "" -%}
{%- for post in posts -%}
  {%- if post.tags -%}
    {%- comment -%} Handle both array and string formats {%- endcomment -%}
    {%- if post.tags.first -%}
      {%- comment -%} Tags is an array (YAML format) {%- endcomment -%}
      {%- for tag in post.tags -%}
        {%- assign trimmed_tag = tag | strip -%}
        {%- if trimmed_tag != '' -%}
          {%- assign all_tags_raw = all_tags_raw | push: trimmed_tag -%}
        {%- endif -%}
      {%- endfor -%}
    {%- else -%}
      {%- comment -%} Tags is a string (space-separated) {%- endcomment -%}
      {%- assign tag_words = post.tags | split: ' ' -%}
      {%- for tag_word in tag_words -%}
        {%- assign trimmed_tag = tag_word | strip -%}
        {%- if trimmed_tag != '' -%}
          {%- assign all_tags_raw = all_tags_raw | push: trimmed_tag -%}
        {%- endif -%}
      {%- endfor -%}
    {%- endif -%}
  {%- endif -%}
{%- endfor -%}

{%- if all_tags_raw.size > 0 -%}

{%- comment -%} Group tags by normalized version {%- endcomment -%}
{%- assign processed_normalized = "" | split: "" -%}
{%- assign final_tags = "" | split: "" -%}

{%- for tag in all_tags_raw -%}
  {%- assign normalized_tag = tag | replace: '_', ' ' | downcase -%}
  
  {%- unless processed_normalized contains normalized_tag -%}
    {%- assign processed_normalized = processed_normalized | push: normalized_tag -%}
    
    {%- comment -%} Find all variants for this normalized tag {%- endcomment -%}
    {%- assign variants = "" | split: "" -%}
    {%- for candidate in all_tags_raw -%}
      {%- assign candidate_normalized = candidate | replace: '_', ' ' | downcase -%}
      {%- if candidate_normalized == normalized_tag -%}
        {%- assign variants = variants | push: candidate -%}
      {%- endif -%}
    {%- endfor -%}
    
    {%- comment -%} Use best variant and count occurrences {%- endcomment -%}
    {%- assign best_variant = variants | uniq | sort | first -%}
    {%- assign tag_count = variants | size -%}
    
    {%- comment -%} Create properly capitalized display tag {%- endcomment -%}
    {%- assign display_tag = best_variant | replace: '_', ' ' -%}
    {%- assign words = display_tag | split: ' ' -%}
    {%- assign capitalized_words = "" | split: "" -%}
    {%- for word in words -%}
      {%- unless word == blank -%}
        {%- assign first_char = word | slice: 0, 1 | upcase -%}
        {%- assign rest_chars = word | slice: 1, 100 -%}
        {%- assign capitalized_word = first_char | append: rest_chars -%}
        {%- assign capitalized_words = capitalized_words | push: capitalized_word -%}
      {%- endunless -%}
    {%- endfor -%}
    {%- assign display_tag = capitalized_words | join: ' ' -%}
    
    {%- comment -%} Store tag with count info {%- endcomment -%}
    {%- assign tag_info = display_tag | append: '|' | append: tag_count -%}
    {%- assign final_tags = final_tags | push: tag_info -%}
  {%- endunless -%}
{%- endfor -%}

{%- comment -%} Create tag info objects with occurrence counts {%- endcomment -%}
{%- assign tag_objects = "" | split: "" -%}
{%- for tag_info in final_tags -%}
  {%- assign parts = tag_info | split: '|' -%}
  {%- assign tag = parts[0] -%}
  {%- assign count = parts[1] | plus: 0 -%}
  {%- assign tag_with_count = tag | append: '|' | append: count -%}
  {%- assign tag_objects = tag_objects | push: tag_with_count -%}
{%- endfor -%}

{%- comment -%} Sort all tags alphabetically {%- endcomment -%}
{%- assign sorted_tag_objects = tag_objects | sort -%}

{%- comment -%} Add date filter tags {%- endcomment -%}
{%- assign date_filters = 'Last 3 days,Last 7 days,Last 30 days,Last 365 days,All time' | split: ',' -%}

<div id="tag-filters" style="margin-bottom: 15px;">
  <button class="tag-filter-btn clear-btn" onclick="clearFilters()">Clear All</button>
  
  {%- comment -%} Date filter buttons {%- endcomment -%}
  {%- for tag in date_filters -%}
    <button class="tag-filter-btn date-filter-btn" data-tag="{{ tag | downcase | escape }}" onclick="toggleFilter('{{ tag | downcase | escape }}')">{{ tag | escape }}</button>
  {%- endfor -%}
  
  {%- comment -%} All tag buttons (multiple and single occurrence, sorted alphabetically) {%- endcomment -%}
  {%- for tag_object in sorted_tag_objects -%}
    {%- assign parts = tag_object | split: '|' -%}
    {%- assign tag = parts[0] -%}
    {%- assign count = parts[1] | plus: 0 -%}
    {%- if count > 1 -%}
      <button class="tag-filter-btn" data-tag="{{ tag | downcase | escape }}" onclick="toggleFilter('{{ tag | downcase | escape }}')">{{ tag | escape }}</button>
    {%- else -%}
      <button class="tag-filter-btn single-tag-btn" data-tag="{{ tag | downcase | escape }}" onclick="toggleFilter('{{ tag | downcase | escape }}')">{{ tag | escape }}</button>
    {%- endif -%}
  {%- endfor -%}
  
  {%- comment -%} Check if we have any single-occurrence tags to show the More button {%- endcomment -%}
  {%- assign has_single_tags = false -%}
  {%- for tag_object in sorted_tag_objects -%}
    {%- assign parts = tag_object | split: '|' -%}
    {%- assign count = parts[1] | plus: 0 -%}
    {%- if count == 1 -%}
      {%- assign has_single_tags = true -%}
      {%- break -%}
    {%- endif -%}
  {%- endfor -%}
  
  {%- if has_single_tags -%}
    <button class="tag-filter-btn toggle-btn" onclick="toggleSingleTags()" id="toggle-single-tags">More</button>
  {%- endif -%}
</div>

<script>
let activeFilters = new Set();
let singleTagsVisible = false;

const dateFilters = ['last 3 days', 'last 7 days', 'last 30 days', 'last 365 days', 'all time'];
const daysMap = {
  'last 3 days': 3,
  'last 7 days': 7,
  'last 30 days': 30,
  'last 365 days': 365
};

// Initialize from URL parameters
function initializeFilters() {
  const urlParams = new URLSearchParams(window.location.search);
  const filters = urlParams.get('filters');
  if (filters) {
    activeFilters = new Set(filters.split(',').filter(f => f.trim()));
  }
  const showSingle = urlParams.get('showSingle');
  if (showSingle === 'true') {
    singleTagsVisible = true;
  }
  updateSingleTagsVisibility();
  updateDisplay();
}

function updateSingleTagsVisibility() {
  const singleTagButtons = document.querySelectorAll('.single-tag-btn');
  singleTagButtons.forEach(btn => {
    if (singleTagsVisible) {
      btn.classList.add('show');
    } else {
      btn.classList.remove('show');
    }
  });
  
  const toggleBtn = document.getElementById('toggle-single-tags');
  if (toggleBtn) {
    toggleBtn.textContent = singleTagsVisible ? 'Less' : 'More';
    toggleBtn.classList.toggle('active', singleTagsVisible);
  }
}

function toggleSingleTags() {
  singleTagsVisible = !singleTagsVisible;
  updateSingleTagsVisibility();
  updateURL();
}

function updateURL() {
  const url = new URL(window.location);
  if (activeFilters.size > 0) {
    url.searchParams.set('filters', Array.from(activeFilters).join(','));
  } else {
    url.searchParams.delete('filters');
  }
  url.searchParams[singleTagsVisible ? 'set' : 'delete']('showSingle', 'true');
  window.history.replaceState({}, '', url);
}

function toggleFilter(tag) {
  const isDateFilter = dateFilters.includes(tag);
  
  if (isDateFilter) {
    if (activeFilters.has(tag)) {
      activeFilters.delete(tag);
    } else {
      dateFilters.forEach(filter => activeFilters.delete(filter));
      activeFilters.add(tag);
    }
  } else {
    activeFilters[activeFilters.has(tag) ? 'delete' : 'add'](tag);
  }
  
  updateDisplay();
  updateURL();
}

function clearFilters() {
  activeFilters.clear();
  updateDisplay();
  updateURL();
}

function normalizeTag(tag) {
  return tag.replace(/_/g, ' ').toLowerCase();
}

function wordMatches(tag, filter) {
  const regex = new RegExp('\\b' + filter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i');
  return regex.test(tag);
}

function isWithinDateRange(postDate, daysBack) {
  const now = new Date();
  const cutoffDate = new Date(now.getTime() - (daysBack * 24 * 60 * 60 * 1000));
  return new Date(postDate) >= cutoffDate;
}

function updateDisplay() {
  const posts = document.querySelectorAll('.post-item');
  const tagButtons = document.querySelectorAll('.tag-filter-btn:not(.clear-btn):not(.toggle-btn)');
  const availableTags = new Set();
  
  const activeDateFilter = Array.from(activeFilters).find(filter => dateFilters.includes(filter));
  const tagFiltersActive = Array.from(activeFilters).filter(filter => !dateFilters.includes(filter));
  
  // Filter posts
  posts.forEach(post => {
    const postTagsRaw = (post.getAttribute('data-tags') || '').split(',').filter(t => t.trim());
    const postTagsNormalized = postTagsRaw.map(normalizeTag);
    const postDate = post.getAttribute('data-date');
    
    const passesTagFilter = tagFiltersActive.length === 0 || 
      tagFiltersActive.every(filter => 
        postTagsNormalized.some(tag => wordMatches(tag, filter))
      );
    
    let passesDateFilter = true;
    if (activeDateFilter && activeDateFilter !== 'all time') {
      const daysBack = daysMap[activeDateFilter];
      passesDateFilter = isWithinDateRange(postDate, daysBack);
    }
    
    const isVisible = passesTagFilter && passesDateFilter;
    post.style.display = isVisible ? '' : 'none';
    
    if (isVisible) {
      postTagsNormalized.forEach(tag => availableTags.add(tag));
    }
  });
  
  // Update tag button states
  tagButtons.forEach(btn => {
    const tag = btn.getAttribute('data-tag');
    const isActive = activeFilters.has(tag);
    const isDateFilter = dateFilters.includes(tag);
    
    const isAvailable = isDateFilter || 
      availableTags.has(tag) || 
      Array.from(availableTags).some(availableTag => wordMatches(availableTag, tag)) ||
      activeFilters.size === 0;
    
    btn.classList.toggle('active', isActive);
    btn.classList.toggle('disabled', !isAvailable);
    btn.disabled = !isAvailable;
  });
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', initializeFilters);
</script>
{%- endif -%}
