{%- comment -%} Collect and process all tags {%- endcomment -%}
{%- assign all_tags_raw = "" | split: "" -%}
{%- for post in posts -%}
  {%- if post.tags -%}
    {%- if post.tags.first -%}
      {%- comment -%} YAML array format {%- endcomment -%}
      {%- assign all_tags_raw = all_tags_raw | concat: post.tags -%}
    {%- else -%}
      {%- comment -%} Space-separated string format {%- endcomment -%}
      {%- assign tag_words = post.tags | split: ' ' -%}
      {%- assign all_tags_raw = all_tags_raw | concat: tag_words -%}
    {%- endif -%}
  {%- endif -%}
{%- endfor -%}

{%- comment -%} Clean and process tags {%- endcomment -%}
{%- assign clean_tags = "" | split: "" -%}
{%- for tag in all_tags_raw -%}
  {%- assign clean_tag = tag | strip -%}
  {%- if clean_tag != '' -%}
    {%- assign clean_tags = clean_tags | push: clean_tag -%}
  {%- endif -%}
{%- endfor -%}

{%- if clean_tags.size > 0 -%}

{%- comment -%} Group tags by normalized version {%- endcomment -%}
{%- assign processed_normalized = "" | split: "" -%}
{%- assign final_tags = "" | split: "" -%}

{%- for tag in clean_tags -%}
  {%- assign normalized_tag = tag | replace: '_', ' ' | downcase -%}
  
  {%- unless processed_normalized contains normalized_tag -%}
    {%- assign processed_normalized = processed_normalized | push: normalized_tag -%}
    
    {%- comment -%} Find all variants for this normalized tag {%- endcomment -%}
    {%- assign variants = "" | split: "" -%}
    {%- for candidate in clean_tags -%}
      {%- assign candidate_normalized = candidate | replace: '_', ' ' | downcase -%}
      {%- if candidate_normalized == normalized_tag -%}
        {%- assign variants = variants | push: candidate -%}
      {%- endif -%}
    {%- endfor -%}
    
    {%- comment -%} Use best variant and count occurrences {%- endcomment -%}
    {%- assign best_variant = variants | uniq | sort | first -%}
    {%- assign tag_count = variants | size -%}
    
    {%- comment -%} Create properly capitalized display tag {%- endcomment -%}
    {%- assign words = best_variant | replace: '_', ' ' | split: ' ' -%}
    {%- assign capitalized_words = "" | split: "" -%}
    {%- for word in words -%}
      {%- assign word_upper = word | upcase -%}
      {%- if word == word_upper -%}
        {%- comment -%} Word is all uppercase (like "AI"), keep as is {%- endcomment -%}
        {%- assign capitalized_words = capitalized_words | push: word -%}
      {%- else -%}
        {%- comment -%} Capitalize first letter only {%- endcomment -%}
        {%- assign capitalized_word = word | capitalize -%}
        {%- assign capitalized_words = capitalized_words | push: capitalized_word -%}
      {%- endif -%}
    {%- endfor -%}
    {%- assign display_tag = capitalized_words | join: ' ' -%}
    
    {%- comment -%} Store tag with count info {%- endcomment -%}
    {%- assign tag_info = display_tag | append: '|' | append: tag_count -%}
    {%- assign final_tags = final_tags | push: tag_info -%}
  {%- endunless -%}
{%- endfor -%}

{%- comment -%} Sort all tags alphabetically {%- endcomment -%}
{%- assign sorted_tag_objects = final_tags | sort -%}

{%- comment -%} Add date filter tags {%- endcomment -%}
{%- assign date_filters = 'Last 3 days,Last 7 days,Last 30 days,Last 365 days,All time' | split: ',' -%}

<div id="tag-filters" style="margin-bottom: 15px;">
  <button class="tag-filter-btn clear-btn" onclick="clearFilters()">Clear All</button>
  
  {%- comment -%} Date filter buttons {%- endcomment -%}
  {%- for tag in date_filters -%}
    <button class="tag-filter-btn date-filter-btn" data-tag="{{ tag | downcase | escape }}" onclick="toggleFilter('{{ tag | downcase | escape }}')">{{ tag | escape }}</button>
  {%- endfor -%}
  
  {%- comment -%} All tag buttons (multiple and single occurrence, sorted alphabetically) {%- endcomment -%}
  {%- assign has_single_tags = false -%}
  {%- for tag_object in sorted_tag_objects -%}
    {%- assign parts = tag_object | split: '|' -%}
    {%- assign tag = parts[0] -%}
    {%- assign count = parts[1] | plus: 0 -%}
    {%- if count > 1 -%}
      <button class="tag-filter-btn" data-tag="{{ tag | downcase | escape }}" onclick="toggleFilter('{{ tag | downcase | escape }}')">{{ tag | escape }}</button>
    {%- else -%}
      {%- assign has_single_tags = true -%}
      <button class="tag-filter-btn single-tag-btn" data-tag="{{ tag | downcase | escape }}" onclick="toggleFilter('{{ tag | downcase | escape }}')">{{ tag | escape }}</button>
    {%- endif -%}
  {%- endfor -%}
  
  {%- if has_single_tags -%}
    <button class="tag-filter-btn toggle-btn" onclick="toggleSingleTags()" id="toggle-single-tags">More</button>
  {%- endif -%}
</div>

<script>
let activeFilters = new Set();
let singleTagsVisible = false;

const dateFilters = ['last 3 days', 'last 7 days', 'last 30 days', 'last 365 days', 'all time'];
const daysMap = {
  'last 3 days': 3,
  'last 7 days': 7,
  'last 30 days': 30,
  'last 365 days': 365
};

// Initialize from URL parameters
function initializeFilters() {
  const urlParams = new URLSearchParams(window.location.search);
  const filters = urlParams.get('filters');
  if (filters) {
    activeFilters = new Set(filters.split(',').filter(f => f.trim()));
  }
  const showSingle = urlParams.get('showSingle');
  if (showSingle === 'true') {
    singleTagsVisible = true;
  }
  updateSingleTagsVisibility();
  updateDisplay();
}

function updateSingleTagsVisibility() {
  const singleTagButtons = document.querySelectorAll('.single-tag-btn');
  const toggleBtn = document.getElementById('toggle-single-tags');
  
  singleTagButtons.forEach(btn => btn.classList.toggle('show', singleTagsVisible));
  
  if (toggleBtn) {
    toggleBtn.textContent = singleTagsVisible ? 'Less' : 'More';
    toggleBtn.classList.toggle('active', singleTagsVisible);
  }
}

function toggleSingleTags() {
  singleTagsVisible = !singleTagsVisible;
  updateSingleTagsVisibility();
  updateURL();
}

function updateURL() {
  const url = new URL(window.location);
  
  if (activeFilters.size > 0) {
    url.searchParams.set('filters', Array.from(activeFilters).join(','));
  } else {
    url.searchParams.delete('filters');
  }
  
  if (singleTagsVisible) {
    url.searchParams.set('showSingle', 'true');
  } else {
    url.searchParams.delete('showSingle');
  }
  
  window.history.replaceState({}, '', url);
}

function toggleFilter(tag) {
  const isDateFilter = dateFilters.includes(tag);
  
  if (isDateFilter) {
    // Only allow one date filter at a time
    if (activeFilters.has(tag)) {
      activeFilters.delete(tag);
    } else {
      dateFilters.forEach(filter => activeFilters.delete(filter));
      activeFilters.add(tag);
    }
  } else {
    // Toggle tag filter
    if (activeFilters.has(tag)) {
      activeFilters.delete(tag);
    } else {
      activeFilters.add(tag);
    }
  }
  
  updateDisplay();
  updateURL();
}

function clearFilters() {
  activeFilters.clear();
  updateDisplay();
  updateURL();
}

function normalizeTag(tag) {
  return tag.replace(/_/g, ' ').toLowerCase();
}

function wordMatches(tag, filter) {
  const regex = new RegExp('\\b' + filter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i');
  return regex.test(tag);
}

function isWithinDateRange(postDate, daysBack) {
  const now = new Date();
  const cutoffDate = new Date(now.getTime() - (daysBack * 24 * 60 * 60 * 1000));
  return new Date(postDate) >= cutoffDate;
}

function updateDisplay() {
  const posts = document.querySelectorAll('.post-item');
  const tagButtons = document.querySelectorAll('.tag-filter-btn:not(.clear-btn):not(.toggle-btn)');
  const availableTags = new Set();
  
  const activeDateFilter = Array.from(activeFilters).find(filter => dateFilters.includes(filter));
  const tagFiltersActive = Array.from(activeFilters).filter(filter => !dateFilters.includes(filter));
  
  // Filter posts
  posts.forEach(post => {
    const postTagsRaw = (post.getAttribute('data-tags') || '').split(',').filter(t => t.trim());
    const postTagsNormalized = postTagsRaw.map(normalizeTag);
    const postDate = post.getAttribute('data-date');
    
    const passesTagFilter = tagFiltersActive.length === 0 || 
      tagFiltersActive.every(filter => 
        postTagsNormalized.some(tag => wordMatches(tag, filter))
      );
    
    let passesDateFilter = true;
    if (activeDateFilter && activeDateFilter !== 'all time') {
      const daysBack = daysMap[activeDateFilter];
      passesDateFilter = isWithinDateRange(postDate, daysBack);
    }
    
    const isVisible = passesTagFilter && passesDateFilter;
    post.style.display = isVisible ? '' : 'none';
    
    if (isVisible) {
      postTagsNormalized.forEach(tag => availableTags.add(tag));
    }
  });
  
  // Update tag button states
  tagButtons.forEach(btn => {
    const tag = btn.getAttribute('data-tag');
    const isActive = activeFilters.has(tag);
    const isDateFilter = dateFilters.includes(tag);
    
    const isAvailable = isDateFilter || 
      availableTags.has(tag) || 
      Array.from(availableTags).some(availableTag => wordMatches(availableTag, tag)) ||
      activeFilters.size === 0;
    
    btn.classList.toggle('active', isActive);
    btn.classList.toggle('disabled', !isAvailable);
    btn.disabled = !isAvailable;
  });
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', initializeFilters);
</script>
{%- endif -%}
